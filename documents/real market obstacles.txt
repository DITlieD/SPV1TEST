This is a critical evolution for the "Fallen God" project. Optimizing strategies in an idealized simulation (frictionless market) leads to fragile models that fail when confronted with the realities of live execution. To ensure the system is prepared for live deployment, we must significantly enhance the realism of the simulation environments (backtesting and RL training).

Here is a super detailed To-Do list to implement realistic modeling of Order Fills, Slippage, Market Impact, and Latency.

### Phase 1: Data Prerequisites and Infrastructure

High-fidelity simulation requires granular data and a capable backtesting engine.

**1.1. Ensure High-Resolution Data Availability**

  * **File:** `data_processing_v2.py`
  * **Action:** Ensure the data pipeline reliably fetches and processes at least 1-Minute (1M) OHLCV data. This is essential for simulating realistic order fills and liquidity within the tactical timeframe (e.g., 15M).

**1.2. Optimize Backtesting Engine (Vectorization)**

  * **File:** `backtester.py`
  * **Action:** The added complexity will slow down simulations. It is crucial that the migration to a vectorized engine like `vectorbt` is completed. The following steps assume `vectorbt` is the core engine.

### Phase 2: Enhancing `backtester.py` (The Forge/Crucible)

We will customize the `vectorbt` simulation logic to incorporate realistic frictions.

**2.1. Implement Latency Simulation (Signal Shifting)**

  * **Goal:** Account for the delay between signal generation and execution arrival at the exchange.
  * **File:** `backtester.py`
  * **Implementation:** In a vectorized backtest, the simplest and most robust way to simulate latency is to ensure execution occurs on the *next* bar's open.
  * **Steps:**
    1.  When calling `vbt.Portfolio.from_signals`, ensure the `price` parameter is set to the 'Open' column of the data.
    2.  Ensure signals are shifted appropriately (if not already handled by the signal generation logic).

<!-- end list -->

```python
# Example snippet in backtester.py
portfolio = vbt.Portfolio.from_signals(
    data,
    entries=signals['entry'],
    exits=signals['exit'],
    price='Open' # Execute at the next bar's open
)
```

**2.2. Implement Dynamic Execution Cost Modeling (Slippage + Impact)**

We will combine Slippage and Market Impact into a comprehensive cost model based on volatility and order size.

  * **File:** `backtester.py`
  * **Inputs:** Volatility (e.g., ATR or EGARCH forecast) and Average Daily Volume (ADV).

**A. Define the Cost Function (Square Root Law Integration):**

  * The Square Root Law effectively models both the cost of crossing the spread (slippage) and the cost of moving the market (impact).

<!-- end list -->

```python
def calculate_execution_cost(data, adv, impact_coefficient=0.1):
    # data must include 'volatility' (e.g., ATR) and 'price' (e.g., Open)

    # Calculate the impact cost relative to the price
    # Impact = Coefficient * Volatility * sqrt(OrderSize / ADV)

    # In a vectorized simulation, we often optimize the *strategy* rather than specific order sizes.
    # We can assume a typical order size relative to ADV, or more robustly, calculate the cost dynamically during simulation based on the actual order placed.

    # Simpler approach: Volatility-based slippage as a proxy for cost
    SLIPPAGE_FACTOR = 0.1 # e.g., Cost is 10% of the current ATR
    dynamic_cost_amount = data['atr'] * SLIPPAGE_FACTOR
    dynamic_cost_pct = dynamic_cost_amount / data['Open']
    return dynamic_cost_pct
```

**B. Integration in `vectorbt`:**

  * **Steps:**
    1.  Calculate the `dynamic_cost_pct` array before the simulation.
    2.  Pass it to the `slippage` parameter.

<!-- end list -->

```python
dynamic_cost_pct = calculate_execution_cost(data, adv)

portfolio = vbt.Portfolio.from_signals(
    data,
    # ... signals ...
    slippage=dynamic_cost_pct,
    fees=0.001, # Add commission fees as well
)
```

**2.3. Implement Conservative Order Fills (Liquidity Constraints)**

  * **Goal:** Make fills more realistic than just touching the price.
  * **File:** `backtester.py`

**A. Limit Order "Trade-Through":**

  * **Action:** Ensure the simulation logic requires the price to move *through* the limit. For a Buy Limit at Price L, the bar's `Low` must be `< L`. `vectorbt` handles this correctly by default when configured properly.

**B. Volume Constraints (Liquidity Modeling):**

  * **Action:** Limit the maximum trade size per bar based on actual market volume.
  * **Steps:**
    1.  Define a `MAX_PARTICIPATION_RATE` (e.g., 0.20 or 20%).
    2.  In the simulation logic, cap the executed order size: `ExecutedSize = min(OrderSize, Volume[current_bar] * MAX_PARTICIPATION_RATE)`.
    3.  *Note: Handling partial fills significantly complicates vectorized backtesting. A pragmatic alternative is to use the standard fill logic but ensure the Market Impact model (2.2) heavily penalizes orders that exceed this participation rate.*

### Phase 3: Enhancing `market_simulator.py` (RL Environment)

The RL environment operates step-by-step, allowing for more granular and realistic simulation, including randomized latency.

**3.1. Integrate Realistic Execution Costs**

  * **File:** `market_simulator.py` (specifically the `step` function)
  * **Steps:**
    1.  Implement the Dynamic Execution Cost model (from 2.2).
    2.  Calculate these costs based on the market conditions at the time of execution.
    3.  Apply the costs to the fill price, ensuring the reward calculation reflects these frictions.

**3.2. Implement Stochastic Latency Simulation**

  * **Goal:** Simulate variable network and processing delays.
  * **File:** `market_simulator.py`
  * **Steps:**
    1.  Define a realistic latency distribution (e.g., Gamma distribution, often used for network delays).
    2.  When the RL agent takes an action (places an order), sample a delay (e.g., 50ms to 500ms).
    3.  The simulation must advance its internal state by this delay.
    4.  The fill price must be determined by the market state *after* the delay has passed.

**3.3. Implement Domain Randomization (CRITICAL)**

  * **Goal:** Prevent the RL agent from overfitting to the simulation parameters.
  * **File:** `market_simulator.py` (specifically the `reset` function)
  * **Steps:**
    1.  Identify the simulation parameters: `SLIPPAGE_FACTOR`, `Impact_Coefficient`, Latency distribution parameters.
    2.  At the start of each episode (`reset`), randomize these parameters within realistic bounds (e.g., vary the `SLIPPAGE_FACTOR` by +/- 50%).
    3.  This forces the RL Governor to develop a policy robust enough to handle unpredictable execution quality.

### Phase 4: Evolution Integration

**4.1. Update Fitness Evaluation**

  * **Files:** `elite_tuner.py`, `wfo_manager.py`, `blueprint_factory.py`
  * **Action:** Ensure that the optimization process (WFO, GP) exclusively uses the enhanced, realistic backtester (Phase 2) for all fitness evaluations. The system will now naturally discard strategies whose theoretical edge is smaller than their expected execution costs.